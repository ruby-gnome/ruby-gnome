<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Class: Gio::OutputStream
  
    &mdash; Documentation by YARD 0.9.27
  
</title>

  <link rel="stylesheet" href="../css/style.css" type="text/css" />

  <link rel="stylesheet" href="../css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "Gio::OutputStream";
  relpath = '../';
</script>


  <script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="../class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="../_index.html">Index (O)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../Gio.html" title="Gio (module)">Gio</a></span></span>
     &raquo; 
    <span class="title">OutputStream</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Class: Gio::OutputStream
  
  
  
</h1>
<div class="box_info">
  
  <dl>
    <dt>Inherits:</dt>
    <dd>
      <span class="inheritName">Object</span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next">Gio::OutputStream</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
    </dd>
  </dl>
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>(unknown)</dd>
  </dl>
  
</div>








  
    <h2>
      Instance Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#clear_pending-instance_method" title="#clear_pending (instance method)">#<strong>clear_pending</strong>  &#x21d2; nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Clears the pending flag on <strong>stream</strong>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#close-instance_method" title="#close (instance method)">#<strong>close</strong>(cancellable)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Closes the stream, releasing resources related to it.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#close_async-instance_method" title="#close_async (instance method)">#<strong>close_async</strong>(io_priority, cancellable, callback, user_data)  &#x21d2; nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Requests an asynchronous close of the stream, releasing resources related to it.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#close_finish-instance_method" title="#close_finish (instance method)">#<strong>close_finish</strong>(result)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Closes an output stream.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#flush-instance_method" title="#flush (instance method)">#<strong>flush</strong>(cancellable)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Forces a write of all user-space buffered data for the given <strong>stream</strong>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#flush_async-instance_method" title="#flush_async (instance method)">#<strong>flush_async</strong>(io_priority, cancellable, callback, user_data)  &#x21d2; nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Forces an asynchronous write of all user-space buffered data for the given <strong>stream</strong>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#flush_finish-instance_method" title="#flush_finish (instance method)">#<strong>flush_finish</strong>(result)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Finishes flushing an output stream.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#has_pending-instance_method" title="#has_pending (instance method)">#<strong>has_pending</strong>  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Checks if an output stream has pending actions.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#is_closed-instance_method" title="#is_closed (instance method)">#<strong>is_closed</strong>  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Checks if an output stream has already been closed.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#is_closing-instance_method" title="#is_closing (instance method)">#<strong>is_closing</strong>  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Checks if an output stream is being closed.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#printf-instance_method" title="#printf (instance method)">#<strong>printf</strong>(bytes_written, cancellable, error, format, array)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This is a utility function around g_output_stream_write_all().</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#set_pending-instance_method" title="#set_pending (instance method)">#<strong>set_pending</strong>  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Sets <strong>stream</strong> to have actions pending.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#splice-instance_method" title="#splice (instance method)">#<strong>splice</strong>(source, flags, cancellable)  &#x21d2; Gio::gssize </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Splices an input stream into an output stream.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#splice_async-instance_method" title="#splice_async (instance method)">#<strong>splice_async</strong>(source, flags, io_priority, cancellable, callback, user_data)  &#x21d2; nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Splices a stream asynchronously.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#splice_finish-instance_method" title="#splice_finish (instance method)">#<strong>splice_finish</strong>(result)  &#x21d2; Gio::gssize </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Finishes an asynchronous stream splice operation.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#vprintf-instance_method" title="#vprintf (instance method)">#<strong>vprintf</strong>(bytes_written, cancellable, error, format, args)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This is a utility function around g_output_stream_write_all().</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write-instance_method" title="#write (instance method)">#<strong>write</strong>(buffer, count, cancellable)  &#x21d2; Gio::gssize </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Tries to write <strong>count</strong> bytes from <strong>buffer</strong> into the stream.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_all-instance_method" title="#write_all (instance method)">#<strong>write_all</strong>(buffer, count, bytes_written, cancellable)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Tries to write <strong>count</strong> bytes from <strong>buffer</strong> into the stream.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_all_async-instance_method" title="#write_all_async (instance method)">#<strong>write_all_async</strong>(buffer, count, io_priority, cancellable, callback, user_data)  &#x21d2; nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Request an asynchronous write of <strong>count</strong> bytes from <strong>buffer</strong> into the stream.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_all_finish-instance_method" title="#write_all_finish (instance method)">#<strong>write_all_finish</strong>(result, bytes_written)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Finishes an asynchronous stream write operation started with g_output_stream_write_all_async().</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_async-instance_method" title="#write_async (instance method)">#<strong>write_async</strong>(buffer, count, io_priority, cancellable, callback, user_data)  &#x21d2; nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Request an asynchronous write of <strong>count</strong> bytes from <strong>buffer</strong> into the stream.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_bytes-instance_method" title="#write_bytes (instance method)">#<strong>write_bytes</strong>(bytes, cancellable)  &#x21d2; Gio::gssize </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>A wrapper function for g_output_stream_write() which takes a #GBytes as input.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_bytes_async-instance_method" title="#write_bytes_async (instance method)">#<strong>write_bytes_async</strong>(bytes, io_priority, cancellable, callback, user_data)  &#x21d2; nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>This function is similar to g_output_stream_write_async(), but takes a #GBytes as input.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_bytes_finish-instance_method" title="#write_bytes_finish (instance method)">#<strong>write_bytes_finish</strong>(result)  &#x21d2; Gio::gssize </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Finishes a stream write-from-#GBytes operation.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_finish-instance_method" title="#write_finish (instance method)">#<strong>write_finish</strong>(result)  &#x21d2; Gio::gssize </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Finishes a stream write operation.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#writev-instance_method" title="#writev (instance method)">#<strong>writev</strong>(vectors, n_vectors, bytes_written, cancellable)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Tries to write the bytes contained in the <strong>n_vectors</strong> <strong>vectors</strong> into the stream.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#writev_all-instance_method" title="#writev_all (instance method)">#<strong>writev_all</strong>(vectors, n_vectors, bytes_written, cancellable)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Tries to write the bytes contained in the <strong>n_vectors</strong> <strong>vectors</strong> into the stream.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#writev_all_async-instance_method" title="#writev_all_async (instance method)">#<strong>writev_all_async</strong>(vectors, n_vectors, io_priority, cancellable, callback, user_data)  &#x21d2; nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Request an asynchronous write of the bytes contained in the <strong>n_vectors</strong> <strong>vectors</strong> into the stream.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#writev_all_finish-instance_method" title="#writev_all_finish (instance method)">#<strong>writev_all_finish</strong>(result, bytes_written)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Finishes an asynchronous stream write operation started with g_output_stream_writev_all_async().</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#writev_async-instance_method" title="#writev_async (instance method)">#<strong>writev_async</strong>(vectors, n_vectors, io_priority, cancellable, callback, user_data)  &#x21d2; nil </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Request an asynchronous write of the bytes contained in <strong>n_vectors</strong> <strong>vectors</strong> into the stream.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#writev_finish-instance_method" title="#writev_finish (instance method)">#<strong>writev_finish</strong>(result, bytes_written)  &#x21d2; TrueClass </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'>
<p>Finishes a stream writev operation.</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="clear_pending-instance_method">
  
    #<strong>clear_pending</strong>  &#x21d2; <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Clears the pending flag on <strong>stream</strong>.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="close-instance_method">
  
    #<strong>close</strong>(cancellable)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Closes the stream, releasing resources related to it.</p>

<p>Once the stream is closed, all other operations will return %G_IO_ERROR_CLOSED. Closing a stream multiple times will not return an error.</p>

<p>Closing a stream will automatically flush any outstanding buffers in the stream.</p>

<p>Streams will be automatically closed when the last reference is dropped, but you might want to call this function to make sure resources are released as early as possible.</p>

<p>Some streams might keep the backing store of the stream (e.g. a file descriptor) open after the stream is closed. See the documentation for the individual stream for details.</p>

<p>On failure the first error that happened will be reported, but the close operation will finish as much as possible. A stream that failed to close will still return %G_IO_ERROR_CLOSED for all operations. Still, it is important to check and report the error to the user, otherwise there might be a loss of data as all data might not be written.</p>

<p>If <strong>cancellable</strong> is not nil, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. Cancelling a close will still leave the stream closed, but there some streams can use a faster close that doesn’t block to e.g. check errors. On cancellation (as with any error) there is no guarantee that all written data will reach the target.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional cancellable object</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true on success, false on failure</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="close_async-instance_method">
  
    #<strong>close_async</strong>(io_priority, cancellable, callback, user_data)  &#x21d2; <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Requests an asynchronous close of the stream, releasing resources related to it. When the operation is finished <strong>callback</strong> will be called. You can then call g_output_stream_close_finish() to get the result of the operation.</p>

<p>For behaviour details see g_output_stream_close().</p>

<p>The asynchronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>io_priority</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the io priority of the request.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional cancellable object</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>callback</span>
      
      
        <span class='type'>(<tt>Gio::AsyncReadyCallback</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>callback to call when the request is satisfied</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>user_data</span>
      
      
        <span class='type'>(<tt>GObject</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the data to pass to callback function</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="close_finish-instance_method">
  
    #<strong>close_finish</strong>(result)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Closes an output stream.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>result</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="AsyncResult.html" title="Gio::AsyncResult (module)">Gio::AsyncResult</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GAsync::Result.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true if stream was successfully closed, false otherwise.</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="flush-instance_method">
  
    #<strong>flush</strong>(cancellable)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Forces a write of all user-space buffered data for the given <strong>stream</strong>. Will block during the operation. Closing the stream will implicitly cause a flush.</p>

<p>This function is optional for inherited classes.</p>

<p>If <strong>cancellable</strong> is not nil, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error %G_IO_ERROR_CANCELLED will be returned.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional cancellable object</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true on success, false on error</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="flush_async-instance_method">
  
    #<strong>flush_async</strong>(io_priority, cancellable, callback, user_data)  &#x21d2; <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Forces an asynchronous write of all user-space buffered data for the given <strong>stream</strong>. For behaviour details see g_output_stream_flush().</p>

<p>When the operation is finished <strong>callback</strong> will be called. You can then call g_output_stream_flush_finish() to get the result of the operation.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>io_priority</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the io priority of the request.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>callback</span>
      
      
        <span class='type'>(<tt>Gio::AsyncReadyCallback</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GAsync::ReadyCallback to call when the request is satisfied</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>user_data</span>
      
      
        <span class='type'>(<tt>GObject</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the data to pass to callback function</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="flush_finish-instance_method">
  
    #<strong>flush_finish</strong>(result)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Finishes flushing an output stream.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>result</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="AsyncResult.html" title="Gio::AsyncResult (module)">Gio::AsyncResult</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GAsyncResult.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true if flush operation succeeded, false otherwise.</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="has_pending-instance_method">
  
    #<strong>has_pending</strong>  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Checks if an output stream has pending actions.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true if <strong>stream</strong> has pending actions.</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="is_closed-instance_method">
  
    #<strong>is_closed</strong>  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Checks if an output stream has already been closed.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true if <strong>stream</strong> is closed. false otherwise.</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="is_closing-instance_method">
  
    #<strong>is_closing</strong>  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Checks if an output stream is being closed. This can be used inside e.g. a flush implementation to see if the flush (or other i/o operation) is called from within the closing operation.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true if <strong>stream</strong> is being closed. false otherwise.</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="printf-instance_method">
  
    #<strong>printf</strong>(bytes_written, cancellable, error, format, array)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This is a utility function around g_output_stream_write_all(). It uses g_strdup_vprintf() to turn <strong>format</strong> and @… into a string that is then written to <strong>stream</strong>.</p>

<p>See the documentation of g_output_stream_write_all() about the behavior of the actual write operation.</p>

<p>Note that partial writes cannot be properly checked with this function due to the variable length of the written string, if you need precise control over partial write failures, you need to create you own printf()-like wrapper around g_output_stream_write() or g_output_stream_write_all().</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>bytes_written</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>location to store the number of bytes that was written to the stream</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>error</span>
      
      
        <span class='type'>(<tt>GLib::Error</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>location to store the error occurring, or nil to ignore</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>format</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the format string. See the printf() documentation</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>array</span>
      
      
        <span class='type'>(<tt>Array</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the parameters to insert into the format string</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true on success, false if there was an error</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="set_pending-instance_method">
  
    #<strong>set_pending</strong>  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Sets <strong>stream</strong> to have actions pending. If the pending flag is already set or <strong>stream</strong> is closed, it will return false and set <strong>error</strong>.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true if pending was previously unset and is now set.</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="splice-instance_method">
  
    #<strong>splice</strong>(source, flags, cancellable)  &#x21d2; <tt>Gio::gssize</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Splices an input stream into an output stream.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>source</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="InputStream.html" title="Gio::InputStream (class)">Gio::InputStream</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GInput::Stream.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>flags</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="OutputStreamSpliceFlags.html" title="Gio::OutputStreamSpliceFlags (module)">Gio::OutputStreamSpliceFlags</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a set of GOutput::StreamSpliceFlags.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Gio::gssize</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a #gssize containing the size of the data spliced, or -1 if an error occurred. Note that if the number of bytes spliced is greater than %G_MAXSSIZE, then that will be returned, and there is no way to determine the actual number of bytes spliced.</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="splice_async-instance_method">
  
    #<strong>splice_async</strong>(source, flags, io_priority, cancellable, callback, user_data)  &#x21d2; <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Splices a stream asynchronously. When the operation is finished <strong>callback</strong> will be called. You can then call g_output_stream_splice_finish() to get the result of the operation.</p>

<p>For the synchronous, blocking version of this function, see g_output_stream_splice().</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>source</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="InputStream.html" title="Gio::InputStream (class)">Gio::InputStream</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GInput::Stream.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>flags</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="OutputStreamSpliceFlags.html" title="Gio::OutputStreamSpliceFlags (module)">Gio::OutputStreamSpliceFlags</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a set of GOutput::StreamSpliceFlags.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>io_priority</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the io priority of the request.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>callback</span>
      
      
        <span class='type'>(<tt>Gio::AsyncReadyCallback</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GAsync::ReadyCallback.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>user_data</span>
      
      
        <span class='type'>(<tt>GObject</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>user data passed to <strong>callback</strong>.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="splice_finish-instance_method">
  
    #<strong>splice_finish</strong>(result)  &#x21d2; <tt>Gio::gssize</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Finishes an asynchronous stream splice operation.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>result</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="AsyncResult.html" title="Gio::AsyncResult (module)">Gio::AsyncResult</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GAsync::Result.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Gio::gssize</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a #gssize of the number of bytes spliced. Note that if the number of bytes spliced is greater than %G_MAXSSIZE, then that will be returned, and there is no way to determine the actual number of bytes spliced.</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="vprintf-instance_method">
  
    #<strong>vprintf</strong>(bytes_written, cancellable, error, format, args)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This is a utility function around g_output_stream_write_all(). It uses g_strdup_vprintf() to turn <strong>format</strong> and <strong>args</strong> into a string that is then written to <strong>stream</strong>.</p>

<p>See the documentation of g_output_stream_write_all() about the behavior of the actual write operation.</p>

<p>Note that partial writes cannot be properly checked with this function due to the variable length of the written string, if you need precise control over partial write failures, you need to create you own printf()-like wrapper around g_output_stream_write() or g_output_stream_write_all().</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>bytes_written</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>location to store the number of bytes that was written to the stream</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>error</span>
      
      
        <span class='type'>(<tt>GLib::Error</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>location to store the error occurring, or nil to ignore</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>format</span>
      
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the format string. See the printf() documentation</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>args</span>
      
      
        <span class='type'>(<tt>Gio::va_list</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the parameters to insert into the format string</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true on success, false if there was an error</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="write-instance_method">
  
    #<strong>write</strong>(buffer, count, cancellable)  &#x21d2; <tt>Gio::gssize</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Tries to write <strong>count</strong> bytes from <strong>buffer</strong> into the stream. Will block during the operation.</p>

<p>If count is 0, returns 0 and does nothing. A value of <strong>count</strong> larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.</p>

<p>On success, the number of bytes written to the stream is returned. It is not an error if this is not the same as the requested size, as it can happen e.g. on a partial I/O error, or if there is not enough storage in the stream. All writes block until at least one byte is written or an error occurs; 0 is never returned (unless <strong>count</strong> is 0).</p>

<p>If <strong>cancellable</strong> is not nil, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error.</p>

<p>On error -1 is returned and <strong>error</strong> is set accordingly.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>buffer</span>
      
      
        <span class='type'>(<tt>Array&lt;Integer&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the buffer containing the data to write.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>count</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the number of bytes to write</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional cancellable object</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Gio::gssize</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>Number of bytes written, or -1 on error</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="write_all-instance_method">
  
    #<strong>write_all</strong>(buffer, count, bytes_written, cancellable)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Tries to write <strong>count</strong> bytes from <strong>buffer</strong> into the stream. Will block during the operation.</p>

<p>This function is similar to g_output_stream_write(), except it tries to write as many bytes as requested, only stopping on an error.</p>

<p>On a successful write of <strong>count</strong> bytes, true is returned, and <strong>bytes_written</strong> is set to <strong>count</strong>.</p>

<p>If there is an error during the operation false is returned and <strong>error</strong> is set to indicate the error status.</p>

<p>As a special exception to the normal conventions for functions that use #GError, if this function returns false (and sets <strong>error</strong>) then <strong>bytes_written</strong> will be set to the number of bytes that were successfully written before the error was encountered.  This functionality is only available from C.  If you need it from another language then you must write your own loop around g_output_stream_write().</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>buffer</span>
      
      
        <span class='type'>(<tt>Array&lt;Integer&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the buffer containing the data to write.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>count</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the number of bytes to write</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>bytes_written</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>location to store the number of bytes that was written to the stream</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true on success, false if there was an error</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="write_all_async-instance_method">
  
    #<strong>write_all_async</strong>(buffer, count, io_priority, cancellable, callback, user_data)  &#x21d2; <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Request an asynchronous write of <strong>count</strong> bytes from <strong>buffer</strong> into the stream. When the operation is finished <strong>callback</strong> will be called. You can then call g_output_stream_write_all_finish() to get the result of the operation.</p>

<p>This is the asynchronous version of g_output_stream_write_all().</p>

<p>Call g_output_stream_write_all_finish() to collect the result.</p>

<p>Any outstanding I/O request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is %G_PRIORITY_DEFAULT.</p>

<p>Note that no copy of <strong>buffer</strong> will be made, so it must stay valid until <strong>callback</strong> is called.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>buffer</span>
      
      
        <span class='type'>(<tt>Array&lt;Integer&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the buffer containing the data to write</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>count</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the number of bytes to write</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>io_priority</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the io priority of the request</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>callback</span>
      
      
        <span class='type'>(<tt>Gio::AsyncReadyCallback</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>callback to call when the request is satisfied</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>user_data</span>
      
      
        <span class='type'>(<tt>GObject</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the data to pass to callback function</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="write_all_finish-instance_method">
  
    #<strong>write_all_finish</strong>(result, bytes_written)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Finishes an asynchronous stream write operation started with g_output_stream_write_all_async().</p>

<p>As a special exception to the normal conventions for functions that use #GError, if this function returns false (and sets <strong>error</strong>) then <strong>bytes_written</strong> will be set to the number of bytes that were successfully written before the error was encountered.  This functionality is only available from C.  If you need it from another language then you must write your own loop around g_output_stream_write_async().</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>result</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="AsyncResult.html" title="Gio::AsyncResult (module)">Gio::AsyncResult</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GAsync::Result</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>bytes_written</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>location to store the number of bytes that was written to the stream</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true on success, false if there was an error</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="write_async-instance_method">
  
    #<strong>write_async</strong>(buffer, count, io_priority, cancellable, callback, user_data)  &#x21d2; <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Request an asynchronous write of <strong>count</strong> bytes from <strong>buffer</strong> into the stream. When the operation is finished <strong>callback</strong> will be called. You can then call g_output_stream_write_finish() to get the result of the operation.</p>

<p>During an async request no other sync and async calls are allowed, and will result in %G_IO_ERROR_PENDING errors.</p>

<p>A value of <strong>count</strong> larger than %G_MAXSSIZE will cause a %G_IO_ERROR_INVALID_ARGUMENT error.</p>

<p>On success, the number of bytes written will be passed to the <strong>callback</strong>. It is not an error if this is not the same as the requested size, as it can happen e.g. on a partial I/O error, but generally we try to write as many bytes as requested.</p>

<p>You are guaranteed that this method will never fail with %G_IO_ERROR_WOULD_BLOCK - if <strong>stream</strong> can’t accept more data, the method will just wait until this changes.</p>

<p>Any outstanding I/O request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is %G_PRIORITY_DEFAULT.</p>

<p>The asynchronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>

<p>For the synchronous, blocking version of this function, see g_output_stream_write().</p>

<p>Note that no copy of <strong>buffer</strong> will be made, so it must stay valid until <strong>callback</strong> is called. See g_output_stream_write_bytes_async() for a #GBytes version that will automatically hold a reference to the contents (without copying) for the duration of the call.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>buffer</span>
      
      
        <span class='type'>(<tt>Array&lt;Integer&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the buffer containing the data to write.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>count</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the number of bytes to write</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>io_priority</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the io priority of the request.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>callback</span>
      
      
        <span class='type'>(<tt>Gio::AsyncReadyCallback</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>callback to call when the request is satisfied</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>user_data</span>
      
      
        <span class='type'>(<tt>GObject</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the data to pass to callback function</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="write_bytes-instance_method">
  
    #<strong>write_bytes</strong>(bytes, cancellable)  &#x21d2; <tt>Gio::gssize</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>A wrapper function for g_output_stream_write() which takes a #GBytes as input.  This can be more convenient for use by language bindings or in other cases where the refcounted nature of #GBytes is helpful over a bare pointer interface.</p>

<p>However, note that this function may still perform partial writes, just like g_output_stream_write().  If that occurs, to continue writing, you will need to create a new #GBytes containing just the remaining bytes, using g_bytes_new_from_bytes(). Passing the same #GBytes instance multiple times potentially can result in duplicated data in the output stream.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>bytes</span>
      
      
        <span class='type'>(<tt>GLib::Bytes</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the #GBytes to write</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional cancellable object</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Gio::gssize</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>Number of bytes written, or -1 on error</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="write_bytes_async-instance_method">
  
    #<strong>write_bytes_async</strong>(bytes, io_priority, cancellable, callback, user_data)  &#x21d2; <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>This function is similar to g_output_stream_write_async(), but takes a #GBytes as input.  Due to the refcounted nature of #GBytes, this allows the stream to avoid taking a copy of the data.</p>

<p>However, note that this function may still perform partial writes, just like g_output_stream_write_async(). If that occurs, to continue writing, you will need to create a new #GBytes containing just the remaining bytes, using g_bytes_new_from_bytes(). Passing the same #GBytes instance multiple times potentially can result in duplicated data in the output stream.</p>

<p>For the synchronous, blocking version of this function, see g_output_stream_write_bytes().</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>bytes</span>
      
      
        <span class='type'>(<tt>GLib::Bytes</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>The bytes to write</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>io_priority</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the io priority of the request.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>callback</span>
      
      
        <span class='type'>(<tt>Gio::AsyncReadyCallback</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>callback to call when the request is satisfied</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>user_data</span>
      
      
        <span class='type'>(<tt>GObject</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the data to pass to callback function</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="write_bytes_finish-instance_method">
  
    #<strong>write_bytes_finish</strong>(result)  &#x21d2; <tt>Gio::gssize</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Finishes a stream write-from-#GBytes operation.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>result</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="AsyncResult.html" title="Gio::AsyncResult (module)">Gio::AsyncResult</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GAsync::Result.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Gio::gssize</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a #gssize containing the number of bytes written to the stream.</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="write_finish-instance_method">
  
    #<strong>write_finish</strong>(result)  &#x21d2; <tt>Gio::gssize</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Finishes a stream write operation.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>result</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="AsyncResult.html" title="Gio::AsyncResult (module)">Gio::AsyncResult</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GAsync::Result.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Gio::gssize</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a #gssize containing the number of bytes written to the stream.</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="writev-instance_method">
  
    #<strong>writev</strong>(vectors, n_vectors, bytes_written, cancellable)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Tries to write the bytes contained in the <strong>n_vectors</strong> <strong>vectors</strong> into the stream. Will block during the operation.</p>

<p>If <strong>n_vectors</strong> is 0 or the sum of all bytes in <strong>vectors</strong> is 0, returns 0 and does nothing.</p>

<p>On success, the number of bytes written to the stream is returned. It is not an error if this is not the same as the requested size, as it can happen e.g. on a partial I/O error, or if there is not enough storage in the stream. All writes block until at least one byte is written or an error occurs; 0 is never returned (unless <strong>n_vectors</strong> is 0 or the sum of all bytes in <strong>vectors</strong> is 0).</p>

<p>If <strong>cancellable</strong> is not nil, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error %G_IO_ERROR_CANCELLED will be returned. If an operation was partially finished when the operation was cancelled the partial result will be returned, without an error.</p>

<p>Some implementations of g_output_stream_writev() may have limitations on the aggregate buffer size, and will return %G_IO_ERROR_INVALID_ARGUMENT if these are exceeded. For example, when writing to a local file on UNIX platforms, the aggregate buffer size must not exceed %G_MAXSSIZE bytes.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>vectors</span>
      
      
        <span class='type'>(<tt>Array&lt;Gio::OutputVector&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the buffer containing the GOutput::Vectors to write.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>n_vectors</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the number of vectors to write</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>bytes_written</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>location to store the number of bytes that were written to the stream</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional cancellable object</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true on success, false if there was an error</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="writev_all-instance_method">
  
    #<strong>writev_all</strong>(vectors, n_vectors, bytes_written, cancellable)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Tries to write the bytes contained in the <strong>n_vectors</strong> <strong>vectors</strong> into the stream. Will block during the operation.</p>

<p>This function is similar to g_output_stream_writev(), except it tries to write as many bytes as requested, only stopping on an error.</p>

<p>On a successful write of all <strong>n_vectors</strong> vectors, true is returned, and <strong>bytes_written</strong> is set to the sum of all the sizes of <strong>vectors</strong>.</p>

<p>If there is an error during the operation false is returned and <strong>error</strong> is set to indicate the error status.</p>

<p>As a special exception to the normal conventions for functions that use #GError, if this function returns false (and sets <strong>error</strong>) then <strong>bytes_written</strong> will be set to the number of bytes that were successfully written before the error was encountered.  This functionality is only available from C. If you need it from another language then you must write your own loop around g_output_stream_write().</p>

<p>The content of the individual elements of <strong>vectors</strong> might be changed by this function.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>vectors</span>
      
      
        <span class='type'>(<tt>Array&lt;Gio::OutputVector&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the buffer containing the GOutput::Vectors to write.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>n_vectors</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the number of vectors to write</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>bytes_written</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>location to store the number of bytes that were written to the stream</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore.</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true on success, false if there was an error</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="writev_all_async-instance_method">
  
    #<strong>writev_all_async</strong>(vectors, n_vectors, io_priority, cancellable, callback, user_data)  &#x21d2; <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Request an asynchronous write of the bytes contained in the <strong>n_vectors</strong> <strong>vectors</strong> into the stream. When the operation is finished <strong>callback</strong> will be called. You can then call g_output_stream_writev_all_finish() to get the result of the operation.</p>

<p>This is the asynchronous version of g_output_stream_writev_all().</p>

<p>Call g_output_stream_writev_all_finish() to collect the result.</p>

<p>Any outstanding I/O request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is %G_PRIORITY_DEFAULT.</p>

<p>Note that no copy of <strong>vectors</strong> will be made, so it must stay valid until <strong>callback</strong> is called. The content of the individual elements of <strong>vectors</strong> might be changed by this function.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>vectors</span>
      
      
        <span class='type'>(<tt>Array&lt;Gio::OutputVector&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the buffer containing the GOutput::Vectors to write.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>n_vectors</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the number of vectors to write</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>io_priority</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the I/O priority of the request</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>callback</span>
      
      
        <span class='type'>(<tt>Gio::AsyncReadyCallback</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>callback to call when the request is satisfied</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>user_data</span>
      
      
        <span class='type'>(<tt>GObject</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the data to pass to callback function</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="writev_all_finish-instance_method">
  
    #<strong>writev_all_finish</strong>(result, bytes_written)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Finishes an asynchronous stream write operation started with g_output_stream_writev_all_async().</p>

<p>As a special exception to the normal conventions for functions that use #GError, if this function returns false (and sets <strong>error</strong>) then <strong>bytes_written</strong> will be set to the number of bytes that were successfully written before the error was encountered.  This functionality is only available from C.  If you need it from another language then you must write your own loop around g_output_stream_writev_async().</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>result</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="AsyncResult.html" title="Gio::AsyncResult (module)">Gio::AsyncResult</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GAsync::Result</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>bytes_written</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>location to store the number of bytes that were written to the stream</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true on success, false if there was an error</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="writev_async-instance_method">
  
    #<strong>writev_async</strong>(vectors, n_vectors, io_priority, cancellable, callback, user_data)  &#x21d2; <tt>nil</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Request an asynchronous write of the bytes contained in <strong>n_vectors</strong> <strong>vectors</strong> into the stream. When the operation is finished <strong>callback</strong> will be called. You can then call g_output_stream_writev_finish() to get the result of the operation.</p>

<p>During an async request no other sync and async calls are allowed, and will result in %G_IO_ERROR_PENDING errors.</p>

<p>On success, the number of bytes written will be passed to the <strong>callback</strong>. It is not an error if this is not the same as the requested size, as it can happen e.g. on a partial I/O error, but generally we try to write as many bytes as requested.</p>

<p>You are guaranteed that this method will never fail with %G_IO_ERROR_WOULD_BLOCK — if <strong>stream</strong> can’t accept more data, the method will just wait until this changes.</p>

<p>Any outstanding I/O request with higher priority (lower numerical value) will be executed before an outstanding request with lower priority. Default priority is %G_PRIORITY_DEFAULT.</p>

<p>The asynchronous methods have a default fallback that uses threads to implement asynchronicity, so they are optional for inheriting classes. However, if you override one you must override all.</p>

<p>For the synchronous, blocking version of this function, see g_output_stream_writev().</p>

<p>Note that no copy of <strong>vectors</strong> will be made, so it must stay valid until <strong>callback</strong> is called.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>vectors</span>
      
      
        <span class='type'>(<tt>Array&lt;Gio::OutputVector&gt;</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the buffer containing the GOutput::Vectors to write.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>n_vectors</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the number of vectors to write</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>io_priority</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the I/O priority of the request.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>cancellable</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Cancellable.html" title="Gio::Cancellable (class)">Gio::Cancellable</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>optional #GCancellable object, nil to ignore.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>callback</span>
      
      
        <span class='type'>(<tt>Gio::AsyncReadyCallback</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>callback to call when the request is satisfied</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>user_data</span>
      
      
        <span class='type'>(<tt>GObject</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>the data to pass to callback function</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="writev_finish-instance_method">
  
    #<strong>writev_finish</strong>(result, bytes_written)  &#x21d2; <tt>TrueClass</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    
<p>Finishes a stream writev operation.</p>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>result</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="AsyncResult.html" title="Gio::AsyncResult (module)">Gio::AsyncResult</a></span></tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>a GAsync::Result.</p>
</div>
      
    </li>
  
    <li>
      
        <span class='name'>bytes_written</span>
      
      
        <span class='type'>(<tt>Integer</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>location to store the number of bytes that were written to the stream</p>
</div>
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>TrueClass</tt>)</span>
      
      
      
        &mdash;
        <div class='inline'>
<p>true on success, false if there was an error</p>
</div>
      
    </li>
  
</ul>

</div>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Wed Apr 27 01:52:11 2022 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.27 (ruby-3.1.2).
</div>

    </div>
  </body>
</html>